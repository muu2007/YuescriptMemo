# パターンマッチ

tamale.luaというライブラリを使う
ロジックの一番複雑な部分が簡潔に掛けるように使うだけ
構造を調べる
テーブルの等値比較をする(luaは同一性比較(アドレス比較)なので)

- matcherにルール集を渡すと関数を返す
- ルールは条件(パターン)、結果、when(ガード)節
  - リテラルの他`tamale.var'x'`でキャプチャできる。
  - 辞書も扱える
  - Pで正規表現での比較がある
  - 条件が関数のときinputを引数に呼ばれ真であれば成立
    - 条件を関数にする時`=>`にすれば@をcapturesとして使える
  - `partial: true`の時、辞書の一部キーを扱う
    配列は連想配列の一部を使っていることを思い出すと配列への `partial: true` は先頭からのマッチだとわかる。
  - 結果が関数の時capturesが渡され呼ばれる。このときだけ多値を返せる(他の時は2番めに情報が返る)
    - 結果を関数にする時`=>`にすれば@をcapturesとして使える
- matcherのオプションとして
  - idsに値のリストを渡すと、同一比較(アドレス比較)になる
  - indexで優先的に比較するよう関数を定めることができる
  - debugはstderrに色々出力するだけで動作は変わらない？
- 関数全体をパターンマッチにする時`=>`にすれば、第一引数を@で取れる
- 網羅性チェックはされない
- else節の表記法はない(`[], partial: true`で代用)(`->true`でも)。elseが何もしないなら省略できる
- 無限を表すテーブルを渡すとスタックオーバーフローする(たとえ最初の１つ２つしか調べなくても)
- N+1パターンの表記法はない
- lua5.2から非対応の古いライブラリだが、moduleを消し、returnするテーブルを作ってそれに関数をはやしてゆけば対応させることができる

パターン

| 名前                   | 対応            | 備考                 |
| ---------------------- | --------------- | -------------------- |
| 定数パターン           | OK              |
| 変数パターン           | OK              |
| 型パターン             |                 | ガードでやるしか無い |
| ワイルドカードパターン | `var'_'`で代用  |
| シーケンスパターン     | リスト構造      |
| タプルパターン         | 辞書構造        |
| asパターン             | inputで見られる |
| 正規表現パターン       | OK              |
| ガード                 | OK              |

## その他の似た機能

### switchのテーブルマッチング

そのキーを持っているかで分岐

### テーブルを文字列に直して正規表現でマッチするか調べることもできる

[poker.yue](../code/poker.yue)
[ポーカー.yue](../code/ポーカー.yue)
計算コストはかかるが、なが〜いif文を書くより何をやっているかわかりやすいかも

## ML系言語のような関数のオーバーロードを実現するものではなさそう

関数の中だけ

引数の名前と値の辞書を debug.getLocal で作れば同じようなことができるかもしれない
