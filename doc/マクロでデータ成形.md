# マクロでデータ成形

## 現状スペースを含むデータをマクロに渡せない

データ記述、DSL的な記述が手作業なしでそのままluaになる。
DSLのフォーマット考えて読み込む型を考えて……なら、yueそのままDSLとして使えるのでは？(コードとして動いちゃう弱点があるけど)
データをluaに直せばluaの速度ではなくcの速度で読める(luajit -bするとより速い)

## トランスパイル時

マクロはシステムに入っているlua5.4で実行される
実行される環境(love2d/luajit)と別、マクロだけで使うライブラリなどは実行時にはなくて良い
Love2Dに含まれるライブラリを使いたければ、同じ機能のものをluarocksでインストールしなければならない
トランスパイル時は他言語のコンパイル時と同じ
自分のutl.yueはLove2Dがあること前提になってしまったのでマクロでは使えない

## マクロの動作の説明

```yuecode.lua
macro DATE = -> os.date("'%Y-%m-%d'")

-- $DATEでトランスコンパイル時の日付に変わる
```

- マクロは関数と同じようにluaの引数を渡し、文字列で式を返す。
  引数は文字列になってくるので辞書の場合順序が保存されている。
  よって文字列(の式)を返したければ２重のクォーテーションが必要。
- 引数がない時呼び出しのカッコを省略できる
- `$macroA()`で式を、`$macorB[[]]`でデータを渡したいが現状そうなってない。

### 引数を渡す。

- カッコでくるんで渡すとそのまま文字列になって渡るが、syntax checkが入るため、データは渡しにくい
  コード(というかリテラル)を渡す
- シングルクォート・ダブルクォート文字列は先頭末尾にクォートがついたまま渡るので取る必要がある。
- ダブルカリー文字列は先頭、末尾のスペースがtrimされて渡る。

現状、データを渡す完璧な方法がないです。
2dマップデータの先頭と末尾が空白の時、空白とは別の記号(~など)を置くことが必要
でディタにtrailing whitespaceがある場合各行末にも必要。

```yuecode.lua
macro C = (c)-> "#{utf8.codepoint(c)}"
-- yueで$C(a)と書くとluaでは0x61となっている
-- $C"a"では３文字渡ってしまう
```

## テーブルを返したい時

文字列で返す必要があるのでlume.serializeで文字列化する
しかしできた文字列はluaなのでテーブルの記述部分が`:`ではなく`=`になっている。
これを`\gsub('=',': ')`で置き換える必要がある
トランスパイルされた後は見やすいように改行が入る
なお、`{code: .., type: 'lua'}`では代入文の右辺にはできなかった。

## yueコードブロックを返す時

- メソッド呼び出しの`\`は重ねる。
- [bug] super()が展開されない。

## マクロの使い道

> マクロの効用
> マクロの危険
> というページから。
>
> マクロでできること
>
> - 文字の節約、
> - インライン展開の代用(高速化)
> - 引数の評価の制御、抑制(評価しないや、短絡評価などか？)
> - トランスコンパイル時の呼び出し元ソースコードへの展開
> - 呼び出し元の変数を使うこともできる(ダイナミックスコープ？)
>
> 具体的なユースケース
>
> - 定形パターンの簡略化 → コアコードを浮かび上がらせる
> - 新しい構文の代用 → 十分そろってるよ？
> - ミニ言語の埋め込み
> - 宣言的コードに見せる
> - コンパイル時の処理

ミニ言語の埋め込みに他プログラムの呼び出しを使える
(現状:変更するたびに tmp と出力先フォルダにゴミが残る……)

## csvファイルの読み込み

静的なデータなら、luaに直して`luajit -b`しておくと高速に読める
データの変形もしておける

```yuecode.lua
macro readcsv = ->
    import 'lib.lume'
    --import 'lib.inspect'
    lines = lume.array io.lines('assets/2d/パル図鑑/パル図鑑.csv')
    columns = lume.split(lines[1], ',')
    result = [lume.split(l, ',') |> (=>lume.merge(@, {columns[i], e for i, e in ipairs @})) for l in *lines[2,]] -- 配列部分に加え、カラム名:itemも付けた
    result = lume.merge(result, {e[1], i for i, e in ipairs result}) -- 追加情報 名前: index
    "#{lume.serialize(result)\gsub('=',': ')}"

M = $readcsv()
return M
```

## zigマクロ mml2oggマクロ

埋め込みで書くのは楽しいが、埋め込みが有用かというと……
zigはコンパイラキャッシュがあるので毎回コンパイルしても初回のみ時間がかかるが、それがないものは自分で作らなければならない。
