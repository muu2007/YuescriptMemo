# クラス型OOP [yue]

- クロージャーやコルーチンがあるので関数で足りることも多い。
- lua(や javascript)のプロトタイプ型OOPのメソッドチェーンを使うものは忘れて class を書くやつ
- 単一継承
- インスタンスメソッドは`__base`に入る。indexメタメソッドでアクセスされる
  インスタンス変数はテーブルのキーと値になる
  クラス変数・関数は`__class`に入る(`__name`のほかいくつかが埋まっている)
- private には出来ない、全て外側から見える
- インスタンス:self をあらわすアットマーク,super
- 型を表す:`@@a`,super
- 同名の派生元メソッドを呼ぶ `super()`
  コード上の同名であって`@update = coroutine.wrap(@_update)`としてもその中の`super()`は親クラスのupdateを呼ぶわけではない(はず)
  親クラスの関数は保存されているが、変数は同一のObjectとして扱われる
- クラス名はコンストラクタ関数でもある(callメタメソッドが定められている)
- abstract(インスタンスを作れない)やfinal(継承できない)は無い。方針としてabstractクラスはクラス名のはじめにアンダースコアを付けておくことにする。
- new(省略時は super\new が呼ばれる)
- [注意] method の第一引数に self が渡っている、渡ってない間違いはよく起こす
  classmethod の第一引数にはクラスが渡っていることを忘れがち
  メソッド呼び出しは@method()
  プロパティに(メソッドではなく)関数をもたせたとき、糖衣構文の元の形を思い出して@または self.method とすれば呼び出せるはず(\ではなく)
- メソッドはクラス宣言の外で宣言されても良い
  記述上は見えないが、self は渡っているので、プロパティも読める。
- 継承するとメソッドはコピーされメソッドチェーンをたどるのを省略するように読めた(階層が深くなると遅くなるを回避？)
  親クラスのメソッドにアクセスするには同名の関数なら`super()`が使える。違う名前なら`super.__base.methodName(@, param1..)`か？
- mixin(using)で別クラスやテーブルを合成することができる(まだ使ってない)
- newはnewという名前だが、生成後の設定をするもの、ここに早期リターンを書いてもインスタンスは作られる
- 無名クラスをその場で作れるそうだ(関数やテーブルで十分なので使ってない)
  todo: クラスを渡すってどういうこと？builder に渡すのかな？
- 本当は抽象クラスから、具象クラスを派生させて使うのだろうが、型チェックがなく、メリットを感じられないのであまり分けてない
  置き換えられる関数を foo0 に保存、具象サンプルを foo1 という命名にしている
- pythonではprotected methodはアンダースコアをつけていたが、つけるべきか？(まだ複雑じゃないからつける必要がないが)
  日本語名をあえて使うことでprotectedメソッドであることを表す？狭い範囲で使われていることを表す？
- withを使ってnewのあとに調整ができるので、完全なconstructorを作る必要がない。
- issubclassは定義されない``
  ```
  -- A Bはクラス(obj.__class)を渡す
  _G.issubclass = (A, B)-> A == B or (A.__parent and issubclass(A.__parent, B))
  ```

## クラス変数へのアクセスはクラスからのみ

pythonの動作と違ってインスタンス変数が見つからなかった時クラス変数を探すことはない。
インスタンスメソッドからは`@@変数名`で、クラスの外側からは`クラス名.変数名`でアクセスできるが、
インスタンスを変数に持っている場合`instance.__class.変数名`となる

## クラスメソッドの複雑な部分

クラスメソッドを太矢印で書くとクラスオブジェクトをレシーバーとする(第一引数に渡る)メソッドになる。(呼び出し方は`@@methodName()`)
ほとんどの場合はクラス名を単に名前空間として使う関数なので細矢印にするべき。その際の呼び出しは`@@.funcName()`となる。
これは、クラス変数がどちらの書き方をしても同じ(なので短い方しか使わない)ことと合わせると、混乱の元になっていると思う

| 宣言               | 呼び出し           | 備考                       |
| ------------------ | ------------------ | -------------------------- |
| `@classMethod: =>` | `@@classMethod()`  | 第一引数にクラスが渡る     |
| `@classMethod: ->` | `@@.classMethod()` | 第一引数にクラスが渡らない |

またクラスメソッド内で継承元のクラスメソッドを呼ぶ場合 super を使うことはできなかった(多分)

## メソッド呼び出しではない時、`@.`と書く必要がある

例としてクラス(=コンストラクタ関数)をメンバー変数に持つ時、
他と同じ様に`@object()`と書くと、第一引数にselfが渡ってしまう。
しかし、yueからは見分けることができないため、プログラマーが書き方を変えなければならない

## インスタンスにindexメタメソッドは付けられない

indexメタメソッドはフィールド・メソッドを探すのに使うため。
callなら付けられる。
→単純な関数を返すならクロージャを返す関数を書けばクラスにしなくて良い。

同じくフィールド・メソッドがテーブルになっているため、getter/setterをindex/newindexメタメソッドで付けることはできない。

## 関数オーバーロードが無い → 継承先で引数を変えると継承元の関数を塞いでしまう

SelectBox←SelectBoxRetro での体験例

SelectBox の new は様々なボタン郡に対応できる。Retro のほうは縦並びに専門化

先ず、ろくな設計もせずに文字列さえあれば後は計算で出せるだろう → やっぱり構造体必要だった
構造体として辞書を導入。この書換は分解代入があったのでスムーズにできた。
そこで、呼び出す側を最小限の変更で済むよう new に渡す構造体を作る build 関数(クラスメソッド)を作った。

Retro は専門化するので new を変えようと思ったら継承元の自由度を塞いでしまうので、
ここにも build 関数を作ることで、ミニマムな引数のみで済むようにした…が、
`SelectBoxRetro(SelectBoxRetro.buildButtons({"Hello","World"}))`と同じクラス名２回書くことになる

## self は予約語ではない。@や@@もクラス外でも使える

例として、省エネモードで self = Scene.current とすると、
クラスの外だが`@@__name`で現在フォーカスを持つシーンのクラス名を取ることができる

## 関数呼び出しをインスタンス変数と添字に偽装のクラス版

```yuecode.lua

class A
	new: =>
		@propertyA: {<index>: (_, n)-> @_functionA(n)} -- 第一引数にはtableが入ってくる。ここを(n)=>とするとselfがshadowingされることに注意
	_functionA: (n)=>

a = A()
-- 呼び出し側
-- a\_functionA(n)を a.propertyA[n]とできる(他と揃える時つかう)

```

私のluacheckrcではselfのshadowingは無視するよう設定しているためリポートしない

## クラス内クラスはクラス変数にする

- @で外側のクラスを覆い隠してしまう

## class mixing

まだ使ってない
メソッドの数が多い時、そのまま使える時class mixingが使えそうだが、
tween.luaのようにlua製のclassのようなものを活用したい場合、そのまま使えないので所有してラッパを書くほうが良さそう

メソッドをただ`メソッド名: 別クラス.__base.メソッド名`で移植できる。(もちろん継承元クラスのものが精神衛生上いいが、どこからでも可能)
これはluaではメソッドもただ第一引数にselfを渡すだけの関数だから可能なこと

## 型オブジェクト

= 無名型/その場で型を作る。
何に使うのか？
