# ポーカーの役判定プログラム

```yuecode.lua
import 'lume'
-- import 'utf8'

数字, マーク = [i for i=1, 13], {'S', 'C', 'H', 'D'}--{'♠', '♣', '♥', '♦'}
初期化 = -> [{s, r} for r in *数字 for s in *マーク] -- for文２つ組み合わせの内包表記できる
手札を配る = -> 初期化() |> lume.shuffle |> lume.first(5) |> -- lume.first/lastは引数をつけると配列を返す(付けないと値を返す)
	setmetatable({__tostring: => lume.reduce(@, ((a, b)-> a..' '..rawget({S:'♠', C:'♣', H:'♥', D:'♦'}, b[1]) .. rawget({'A','2','3','4','5','6','7','8','9','T','J','Q','K'}, b[2])), '')})

役を判定 = (cards)->
	-- 正規表現ライブラリをつかって判定するため、文字列にする。(この文字列は、人間に見せる表現と違って、正規表現で使いやすいものでよい)
	数字の集合 = [r for {_, r} in *cards] |> lume.sort |> lume.reduce(((a, b)-> a .. string.char(b)),'') -- 変換と結合を一緒にするときはreduceに初期値が必要
	マークの集合 = [s for {s, _}in *cards] |> lume.sort |> lume.reduce(((a, b)-> a .. b))

	フラッシュか = ->マークの集合\match('(.)%1%1%1%1')
	ストレートか = ->
		s = lume.sort([r for {_, r}in *cards])
		'01234' ==  [r-s[1] for r in *s] |> lume.reduce(((a,b)->a..b))

	if ストレートか() and フラッシュか() then 'ストレート・フラッシュ'
	elseif 数字の集合\match('(.)%1%1%1') then 'フォーカード'
	elseif 数字の集合\match('(.)%1%1(.)%2') or 数字の集合\match('(.)%1(.)%2%2') then 'フルハウス'
	elseif フラッシュか() then 'フラッシュ'
	elseif ストレートか() then 'ストレート'
	elseif 数字の集合\match('(.)%1%1') then 'スリーカード'
	elseif 数字の集合\match('(.)%1.?(.)%2') then 'ツーペア'
	elseif 数字の集合\match('(.)%1') then 'ワンペア'
	else '役無し'

for _ = 1, 10
	手札 = 手札を配る()
	print 手札, 役を判定(手札)

-- 配列を簡易構造体として使っている(アクセスするのに`[1]`とか`[2]`とかしている)→識別子にunicode(日本語)を使えれば辞書をつかう(かな？)
-- lua標準の正規表現はutf8を理解しない(utf8ライブラリの外にあることからも明らか)
```

上から順に説明

- コード色付けはyueは無いのでluaを使っています。
- import文はluaのrequireをラップしたもの。yue/luaで書かれたモジュール(=別ファイル)を読み込みます。
  localにモジュール名(この場合はlume)ができます
  asで別名や、内部のいくつかの関数・変数・クラスなどだけをインポートすることもできます
  [yue]仕様: トップレベルにしか書けないようです
  requireを塞いでないので、importが使えない場所ではそちらをつかう。
- (無駄に)日本語(Unicode)識別子を使ってます
  lua5.1/luajitでは通りますが、lua5.4向けでもyueなら使えます(ファイル名、モジュール名も)
  rootブロックでのunicode識別子は変換されるため、`_G['unicode']`とは別物になる(lua5.1でも)
- 多値代入
  yueには多重代入`a = b = 0`もある(が、使ってない)
- lumeは(ゲーム向け)便利関数を集めたモジュール。高階関数など
  lume.first/lastは引数をつけないと最初/最後の値を返す。`lume.first(1)`とすると最初のn個(この場合は１個)のスライスした配列を返す
- 内包表記でトランプの全カードを用意
  この例のようにforを複数組み合わせることも可能
  内包表記は生成の他、map/each、後ろにwhenを置いてselect/rejectなど、高階関数の多くのことができる(reduceなど以外)
  配列を(簡易)構造体として使っている(アクセスするのに`[1]`とか`[2]`とかしている、小さいプログラムならいいだろうけど本当は連想配列などを使うべき)
- 関数の表記が`->`、第一引数にselfをとるもの(メソッド)の表記が`=>`(luaのfunction/return/endと比べると短い)
  インデントでスコープ/ブロックを作り、最後の行を返すpython風表記です。
- パイプ`|>`で関数を前後逆に書けます(思考の順序通りに描くようにする)。
  第一引数に入る。そうでない場合はプレースホルダ`_`が使える
  引数がそれ一つだけならカッコ自体も省略できる。
  プレイスホルダは複数回使えない、計算式の項として使えない。内包表記やテーブルコンストラクタにも使えない。
- 文字列化
  内部では扱いやすいデータ構造にして、結果は人間に読めるように表現を変える
  luaではprint文はテーブルを表示しようとするとアドレスを表示するだけ(それで比較していることを示している？)
  lume.serializeは中身は見られるが、名前の通り保存用
  inspect.luaを使うと人間に読めるようにする。
- thenなどの省略ができる。thenなどをつけると一行にできる。
  インデントでブロックを表す言語の場合elseifはelse ifと同じ(はず)。一行で書くときは必要。
- 関数呼び出しのカッコの省略。(!での呼び出しもあるが使ってない)
  ipairsなどでは使ってるが、カッコを書いたほうが読みやすい場面もある
- 他では使わない変数はアンダースコアで表す(luacheckで検出されないように。先頭がアンダースコアであればいいらしい)
- lua 標準の正規表現は utf8 を理解しない(utf8 ライブラリの外にあることからも明らか)
