# Lua・Yueの細かいところ

他の機能の場所で書いてしまうとノイズになってしまうものをまとめて。

## 識別子と代入文

- [lua] localと書かないとglobalになってしまう。
- [lua] static変数はないのでグローバル変数/インスタンス変数を長い名前にしてそれっぽく使う(例: `_static_foo or= true`)
  スコープが関数内ではないことに注意
- [lua] 多値代入がある(右辺全てを評価してから代入する。左側の変数を使った計算をするときは２行に分ける必要がある)
- [yue] 複合代入演算子(+= or= ..=など)がある(これは多値に対応しない)

## 数値

- +単項演算子はない
- 先頭に0が並んでも良い
- [yue] 数値の間にアンダースコアをはさめるようになった
- [yue] ２項演算子の左右のスペースは全く挟まないか、両方に挟むこと。さもないと関数呼び出しと認識される(例:`a -2`)

### 整数について

Love2D(luajit)なのでlua5.3から導入された整数関連のものは使えない
おぼえるものが少なくなって良い(ビッド演算子、シフト演算、math.typeなど)

## 文字列

- シングルクォート文字列、
  ダブルクォート文字列、
  ダブルカリー文字列(間に=がいくつか入っても良い)がある。先頭と末尾の改行は削除される。
  yueではダブルクォート文字列が複数行に対応。埋め込み式展開(テンプレート)もできるようになった。
- 連結は`..`を使う
- 一文字でも文字列、文字型はない。スライスはsub()を使う、添字でn文字目にアクセスできたりしない
- Flyweight管理
- 文字列が作られるとstringライブラリがメタテーブルに入れられる。(OOP風呼び出し、チェインで繋げられる)
- str[n]は別機能(別ページ)
- luaの正規表現は機能が少ない(orや否定などがない)。なので正規表現とは呼ばないもよう。
  他言語でパターンを引数に受ける場所に同じ様に書いたら、役立たずになるかも
- yueではパイプがあるので、今luaを設計したらメタテーブルに設定する機能を付けなくてもいいかも
- utf8ライブラリが別にある(=正規表現はutf8を理解しない)
- 文字列は他言語のいくつかのものを代用する(が、それぞれの型の小さな便利関数はない)
  - 正規表現パターン
  - ファイルパス
  - 日付と時刻
  - モード(Enumのエントリ？ただしまとめたものはない)
  - バイト配列(\0も含むことができる)

### 数値と文字列の自動変換

luaは文字列と数値の相互自動変換がある
しかし、`arr[1] != arr['1']`です。

```カンマ区切り数値yuecode.lua
numWithCommas =(n)-> tostring(math.floor(n))\reverse()\gsub("(%d%d%d)","%1,")\gsub(",(%-?)$","%1")\reverse()
```

## 多値

- 多値代入や多値返しなど自然に書ける。仮引数に...が置ける。selectで操作できる(そのまま計算は出来ない)
- 多値(関数戻り値が多値のときも)をカッコで囲むと左の一つだけになる。
- 多値(unpackやselectも)をテーブルコンストラクタの最後以外、引数の最後以外に書くとカッコで囲んだかのように１つになる
  `...`(テーブル展開)はそうならない

## テーブル

- 配列の**添字１始まり**
  `{[0]: 0}`とすれば0から使えるが、1からnilが出るまでを配列として使うので(忘れてしまうので)使わないほうが良い
- 値にnilを持てない。`{nil, nil}`は空配列になる。(nilを入れるとキーがなかったことにされる)
- [危険] 無いキーにアクセスするとnilを返す(エラーではない)→luacheckを使う
- yueでは`{}`の他に`[]`でも配列を表記できるようになった(が値１つの時後ろにカンマが必要)
- 純粋なデータ表現(javascriptのようにconstructorやtostringが埋まっていない)
  metatableをセットするかも任意
  →だからpairs/ipairsを使ってイテレーターにする。
- テーブルコンストラクタの中だけ`...`で分解できる。一部を更新したデータを作りたい時など
- [yue] テーブル/クラスの中では`=`の替わりに`: `を使う必要がある
- [yue] 行末のカンマが無くてもよい、最後のカンマは余っても良い。
- ２重の内包表記を書くときは(ダブルカリー文字列に認識されないよう)スペースを入れて書く必要がある。
- pythonのようにテーブルのすぐ後ろに添え字を書くことは出来ない→`{1,2,3}|>rawget(n)`とすればできる
- 関数呼び出しを添え字アクセスに偽装(他と揃える時使う)
- メタテーブルのキーも他のキーと並べて書けるが、その記法の活用法が特に無い
- メタテーブルを`<index>`などと書けるが、種類が少ないので他のキーも同様にかけて欲しいです
  `<index>`と`<>.key`→`<__index>`と`<key>`で

| 関数名      | 引数           | 戻り値     | 備考                                                 |
| ----------- | -------------- | ---------- | ---------------------------------------------------- |
| lume.sort   | 配列, 比較関数 | 新しい配列 | table.sortは破壊的関数(戻り値はnil) 両方非安定ソート |
| lume.remove | table, 値      | 値         | table.removeはindexで指定                            |
| lume.find   | table, 値      | index      | 高階関数でないため、先に変形することも               |

## 関数の記述

- 引数の数が不足すればnilが渡る。余れば使われない
  型も無いので関数のオーバーロードは出来ない
  余る部分に計算を書けば呼び出し前に評価される[CodeGolf]
- nilとfalse以外は全て真(空文字、空テーブルも真)
- 比較。
  - 文字列までは等値比較、テーブルからは同一オブジェクトかを比較(アドレスを比較する)
  - 文字列の大小比較できること忘れがち
  - 型が違うものの`==`と`!=`での比較はfalseが返る(in-expressionでの比較でも使われる。配列の中のゴミデータを無視する的な)
- `~=`が`!=`とも表記できるようになった
- forが２種類ある(数値forとforeach)、レンジオブジェクトはない
- 他言語でdo-whileは`repeat-unitl`
- [lua] returnブロックの最後の文としてしか書けない。途中で必要なときはdoでブロックを作る
  yueでは普通に書ける
- [yue] switch
  `when in [1,9]`という表記が使えたが今はなくなった
- [yue] continue(`--target=5.1`でgotoを使わないものを生成する)
- 関数引数に無名関数を書く時、最後の引数でなければカッコで囲む必要がある
- [lua]では３項演算子は無く、andとorで代用していたが
  [yue]ではifが式なのでこちらを使う
  luaでtrueなどを返さなくてはならなかった部分は使わなく(discard)なった
- if notにはunlessがあるがwhen notにはない(条件式の場所で変数宣言をするためだけにunlessがある？)
  not は演算子の優先順位が高いので注意
- インデントがあるものが関数の続きとみなされる(データ表記と区別)

## クロージャ

- luaの用語: スコープの外側の変数をupvalueと言う
- 遅延評価として
  いま計算しておくことはクロージャの外に、後で計算するものはクロージャにして返す
- lume.memoiseはクロージャで出来ているっぽいのでもう一度flyweightを作れば前のやつはGCが回収する？

## コルーチン

- 非対称(親子関係)コルーチン。ライブラリに分離されていて、何重もの呼び出しができる。
- ゲームでは一時的なアニメーションに使って元のupdateに戻すという使い方をしています。

## エラー処理

pcall/xpcallを yueではtry/catchにまとめている

## [クラス型OOP](クラス型OOP.md)

- luaには決まったクラス作成法が存在しないのが欠点だそうだが、yueで標準的な方法を定めていることになる。
- 自分ではクラスのインデントの中にクラス変数とメソッドを並べて書くのがシンプルだと思っているが、
  別な書き方もできる
  - インスタンス変数は使用するまでに用意されていれば良い。
    ついついnewに全て書いてしまうけれど
  - クラス変数も使用するまでに用意されていれば良い。
    メソッドの中で宣言することも出来、その場合は構築のタイミングが起動時→インスタンス作成時になる(はず)
  - クラスの宣言が一度終わった後で変数やメソッドを加えることもできる(メソッドを加える場合は`__base.`に加える(はず))

## モジュール

- importはルートブロックにしか書けない。(それ以外のときはrequireを使う)
- `package.loaded['モジュール名']`ですでに読み込んでいるかチェックできる。
  これを使って分岐できる(importする順序が重要になる)
- `local *`や`local ^`で関数を上から書かなくても良くなる
- `local name`(前方宣言)でテーブルコンストラクタの中でこれからそれを代入する名前をつかえるようになる
  これはそのブロックのみ有効(`local *`すれば関数の中も有効だと思ってたが違った)
  tamale.matcherを再帰関数にするのに使った

## マクロ

- カッコでコードダブルカリー文字列でデータをを渡す(シングルクォート・ダブルクォート文字列は囲み自体も渡ってしまう)
  と思ったがダブルカリー文字列の動作がluaと違いスペースなどをtrimmingしてしまう→ダブルクォート文字列を使って最初と最後を自分でtrimするしか無い？[bug?/spec?]
- 戻り値は文字列で返す。戻すのが文字列一つならば、２重に囲まなくてはならない
- macroをexportする場合、macroだけのファイルにしなければならない
- マクロをネストしようとしたらうまくかなかった。出来ない？
- luaに残すマクロ使い道がない
  `-c`コマンドラインオプションがあるので
  変換後のluaファイルの行末にコメントが残せないぐらい

## サードパーティ製ライブラリ

lume.lua
: 高階関数やmemoiseなど言語を拡張する関数がある。
いくつかはyueの機能と重なるので使ってない

lcurses
: 小さなゲームライブラリとして利用

luafilesystem
: フォルダ内の全ファイル名を得るのに必要

tamale.lua
: パターンマッチングライブラリ。
moduleがあるが、lua5.4用に修正はできる。全体をテーブルに入れてreturnでそれを返す

luacombine
: 順列、組み合わせ
table.getnを長さ演算子に書き換えが必要
`print inspect [{a,b,c} for a,b,c in combine.combn(s, 3)]`(多値を返すイテレータを返す)
tenpuzzleで、combn(順列)は並べ替えたもの(競馬で言う連単)を作らないので、更にpermute(組み合わせ)をする必要があった

luasort
: 使ってない。安定ソートか？

## 周辺ツール

### luacheck

トランスパイルしたluaファイルに掛ける。とても便利。
vimでluaファイルを(左右に並べて)開くと自動で掛かり`ctrl-e`で一つづつエラーを潰してゆく。
`yue -l`オプションで対応する行番号を得る
selfがshadowingする部分は無視するようにした
クラス内クラスや引数一つの関数を短く書くのにメソッド記法を使ってる

### busted

`if arg[0] == 'ProgramName'`とする代わりに`if packaged.loaded['busted']`として、
モジュールと同じファイルにテストを書けるかやってみる。
実行するときは`yue ModuleName.yue && busted --lang=ja ModuleName.lua`で行う
luajitで速度を見るときはbusted.luaという空ファイルを作れば`luajit -lbusted`で実行できる(bustedでluajitを指定することは出来ない)

### その他

tl check
LDoc
静的コールグラフを書いてくれるものもあったが、関数定義が`name = function()`だと使えなかった

## 型

## FFI整数

luajitでは`ffi.new()`で8~64bit整数を作ることができる。
普通の演算子とbitライブラリで計算できる(高速らしい)

## FFI(ダイナミックリンクライブラリとの連携)

他の言語で作られたCインターフェースのあるライブラリをリンクすることができる。
luaの文字列で連携しにくいときはstring.bufferライブラリがある

## その他

- playgroundではライブラリの読み込み、luajitでの実行は出来ない
- デバックモード/static if はない
  コマンドラインからも指定できない
  Love2Dでの制作ではmacros.yueがあるかどうかでDEBUGMODEを作っている
  `gcc -E`を使ってstatic ifを実現する方法がlua-userにあった。
